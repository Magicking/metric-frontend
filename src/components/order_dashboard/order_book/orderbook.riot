<order-book>

    <div id="order-table-canvas" onscroll={ disableScrollToView }>
        <table class="orders">
            <thead class="order-book-columns">
            <tr id="order-book-header">
                <th>Price { state.outputToken.symbol }</th>
                <th>Amount { state.inputToken.symbol }</th>
                <th>Total { state.outputToken.symbol }</th>
            </tr>
            </thead>
            <tbody>
            <tr each={ask in state.asks} class="ask">
                <td>{ ask.price }</td>
                <td>{ ask.volumeTaker.toFixed(config.displayedDecimalPoints) }</td>
                <td>{ ask.volumeMaker.toFixed(config.displayedDecimalPoints) }</td>
            </tr>
            <tr id="orders-separator"/>
            <tr each={bid in state.bids} class="bid">
                <td>{ bid.price }</td>
                <td>{ bid.volumeTaker.toFixed(config.displayedDecimalPoints) }</td>
                <td>{ bid.volumeMaker.toFixed(config.displayedDecimalPoints) }</td>
            </tr>
            </tbody>
        </table>
    </div>

    <script>
        import './orderbook.css'
        import {
            getBaseToken,
            getOrderBookAsks,
            getOrderBookBids, getQuoteToken,
            registerForOrderBookUpdateEvents
        } from "../../../common/0x_order_book_proxy";

        import {BigNumber} from '@0x/utils';

        export default {
            config: {
                displayedDecimalPoints: 3
            },
            state: {
                asks: [],
                bids: [],
                triggerScrollToView: true,
            },
            onBeforeMount() {
                this.state.inputToken = getBaseToken()
                this.state.outputToken = getQuoteToken()
            },
            onMounted() {
                registerForOrderBookUpdateEvents(this)
            },
            async onBeforeUpdate() {

                if (this.state.inputToken !== getBaseToken() || this.state.outputToken !== getQuoteToken()) {
                    this.state.triggerScrollToView = true
                }

                this.state.inputToken = getBaseToken()
                this.state.outputToken = getQuoteToken()

                this.fetchOrderBook(this.state.inputToken, this.state.outputToken)
            },
            onUpdated() {
                if (this.state.triggerScrollToView) {
                    this.scrollOrderBookIntoView()
                }
            },
            disableScrollToView() {
                this.state.triggerScrollToView = false
            },
            fetchOrderBook(inputToken, outputToken) {

                if (inputToken !== null && outputToken !== null) {

                    let asks =
                        getOrderBookAsks().map(b => {

                            let makerAmount = b.order.makerAssetAmount.dividedBy(10 ** inputToken.decimals)
                            let takerAmount = b.order.takerAssetAmount.dividedBy(10 ** outputToken.decimals)
                            let remainingTakerAmount = new BigNumber(parseInt(b.metaData.remainingFillableTakerAssetAmount)).dividedBy(10 ** outputToken.decimals)
                            let remainingMakerAmount = makerAmount.multipliedBy(remainingTakerAmount.dividedBy(takerAmount))

                            return {
                                price: parseFloat(takerAmount / makerAmount).toFixed(this.config.displayedDecimalPoints),
                                volumeMaker: remainingTakerAmount,
                                volumeTaker: remainingMakerAmount
                            }
                        })

                    let bids =
                        getOrderBookBids().map(b => {

                            let makerAmount = b.order.makerAssetAmount.dividedBy(10 ** inputToken.decimals)
                            let takerAmount = b.order.takerAssetAmount.dividedBy(10 ** outputToken.decimals)
                            let remainingTakerAmount = new BigNumber(parseInt(b.metaData.remainingFillableTakerAssetAmount)).dividedBy(10 ** outputToken.decimals)
                            let remainingMakerAmount = makerAmount.multipliedBy(remainingTakerAmount.dividedBy(takerAmount))

                            return {
                                price: parseFloat(makerAmount / takerAmount).toFixed(this.config.displayedDecimalPoints),
                                volumeMaker: remainingMakerAmount,
                                volumeTaker: remainingTakerAmount
                            }
                        })

                    Array.prototype.sumByPrice = function() {
                        return Object.values(this.reduce(function(groups, item) {
                            const key = item.price
                            groups[key] = groups[key] || {price: key, volumeMaker: 0, volumeTaker: 0}
                            groups[key] = {
                                price:key,
                                volumeMaker: item.volumeMaker.plus(groups[key].volumeMaker),
                                volumeTaker: item.volumeTaker.plus(groups[key].volumeTaker)
                            }
                            return groups
                        }, {}))
                    }

                    this.state.bids =
                        bids
                            .sumByPrice()
                            .sort((a, b) => parseFloat(b.price) - parseFloat(a.price))

                    this.state.asks =
                        asks
                            .sumByPrice()
                            .sort((a, b) => parseFloat(b.price) - parseFloat(a.price))
                }
            },

            scrollOrderBookIntoView() {
                let tableHeader = document.getElementById("order-book-header");
                let orderBookSeparator = document.getElementById("orders-separator");
                let visibleOrderBookRegion = document.getElementById("order-table-canvas");

                let tableHeaderSize = $(tableHeader).height();
                let containerHeight = $(visibleOrderBookRegion).height() - tableHeaderSize;
                let elemTop = orderBookSeparator.offsetTop - tableHeaderSize;

                if (elemTop > containerHeight) {
                    $(visibleOrderBookRegion).scrollTop(elemTop - containerHeight / 2);
                }
            }
        }

    </script>
</order-book>
